\section{RobworkStudio plugin}
\label{sec:plugin}
In addition to the Letter Font application a plugin for RobworkStudio has been created. The purpose of this plugin is to read Cartesian coordinates from a file similar to the one created by the Letter Font program and then output both a RobworkStudio simulation file and a jnt-file for direct use with the Fanuc robot. In addition to the main functionality the plugin has a button to test the input coordinates, and examine if they correspond with the Fanuc robot workspace and outputs the joint values, the button is called "Test".

\subsection{Parser}
\label{sec:parser}
To parse an input file a list of criteria must be met:
\begin{itemize}
	\item Txt file format. The parser only accepts files with the extension txt, even if the files are written in any form of clear text. 
	\item Letter allocation. Coordinates are allocated into subgroups according to letters. The parser scans for the keyword \textit{Letter = \$} to signify a new group of coordinates allocated to a specific letter. A letter can be any character or number except space.
	\item Letter separation. Letters are separated by the keyword \textit{NEXT\_LETTER} to signify the end of a group.
	\item Coordinate formating. Coordinates must be on individual lines, each component separated by a tabular. Coordinates are assumed to be integer (pixel) values corresponding to millimeter offsets on the individual axes from an origin specified by the plugin based on the selected robot device. The X axis specifies the height of text, 0 and negative being furthest from the robot. The Y axis specifies the width of the text, with 0 and negative to the left of the robot. The Z axis specifies the elevation of the toolhead when milling, with 0 at table level and positive values elevating the drill above it.
	\item Density specification. The toolhead will be lifted with a fixed value when moving between letters. This is to avoid carving connecting paths between them. To enable the plugin to lift the toolhead when milling complex letters or gaps in these, the density of coordinates must be specified in the file with the keyword \textit{Density = \$}. The parser assumes that coordinate density is quadratic and therefore equal on both the X and Y axes.
\end{itemize}

If an input file respects this specification the parser will most likely parse the file successfully.\\

The actual implementation of the parser is described in the following section.

\subsubsection{Implementation}
\label{sec:parserImpl}
The sscanf (formatted string reader) and strstr (locate substring) is used to parse the input file. Which is read by ifstream (input file stream). All parse functionality is C portable, primarily because the programmer was familiar with these functionalities, and the functionality was appropriate for the task.  

\subsection{Path planning and joint angle solving}
\label{sec:pathplanning}
Despite its name, path planning is not a feature that is used at all in the final implementation of the plugin. The functionality is implemented based on the Robworks manual, but the overhead imposed by the planner is considerable and the gain was deemed insignificant in the end since mostly all coordinates are inside the target milling material and therefore either always or never collides with an object. In addition the paths between these coordinates are generally short and trivial, rendering the pathPlanner unnecessary. A function called \textit{pathPlanner} exists in the project namespace but is never used and is only provided as an addon for future use.\\

The main part of the plugin handles the conversion from the parsed Cartesian coordinates into rotation values for each of the robots joints. These are determined by using inverse kinematics (henceforth written as IK). More specifically, one of the inbuilt iterative IK solvers called ResolvedRateSolver is used through the IK wrapper IKMetaSolver. The values are then stored in a vector array of configurations. This array is passed to a function that converts each configuration into a joint parameter configuration and printed to the output jnt file.

\subsubsection{Implementation}
\label{sec:pathplanningImpl}
The solver is called when the user presses the \textit{generate} button which is only available if the parse button has previously been pressed and a valid file has been selected.\\
When the \textit{generate} button is clicked, the State is updated to a State with the robot device in the pregenerated ''home'' configuration close to the working area. This is preferable when using the IK solver since it iteratively tries to solve the Cartesian coordinates based on the current State and therefore might reduce the total number of iterations needed to solve the problem.\\
It then iteratively solves each letter coordinate taken in relation to the workarea origin. During this it takes into consideration the distance from the previous coordinate to the current, and if this is larger than the density value of the letter coordinates, the tool head is lifted by inserting two additional configurations with increased Z-values.\\
When all coordinates has been solved or failed, the vector array of configurations is parsed to a function called \textit{writeJNT}. This function uses fprintf to create a string with the joint values formated in and time frame constant added. This is done for each configuration and creates a file in the application directory called \%devicename\%.jnt.\\
Additionally the configurations are converted to states and written to a replay file which allows the user to simulate the output path in RobWorkStudio. This file is also placed in the application directory and is called \%devicename\%.rwplay.
