#include "Assign04.h"

#include <QPushButton>
#include <rw/common/StringUtil.hpp>
#include <iostream>
#include <fstream>

// needed for VS
#define _USE_MATH_DEFINES
#include <cmath>
#define M_PI       3.14159265358979323846

#include <rws/RobWorkStudio.hpp>
#include <rw/pathplanning/PlannerConstraint.hpp>
#include <rwlibs/proximitystrategies/ProximityStrategyYaobi.hpp>
#include <rw/pathplanning/QToQPlanner.hpp>
#include <rw/pathplanning/QSampler.hpp>
#include <rwlibs/pathplanners/sbl/SBLPlanner.hpp>
#include <rw/loaders/path/PathLoader.hpp>
#include <rw/invkin/ResolvedRateSolver.hpp>
#include <rw/invkin/IKMetaSolver.hpp>
#include <rw/models/Models.hpp>

using namespace rw::math;
using namespace rw::common;
using namespace rw::kinematics;
using namespace rw::models;
using namespace rw::pathplanning;
using namespace rwlibs::proximitystrategies;
using namespace rwlibs::pathplanners;
using namespace rwlibs::drawable;
using namespace rw::proximity;
using namespace rw::loaders;
using namespace rw::invkin;
using namespace std;
using ::boost::math::abs;

assign04::assign04():
RobWorkStudioPlugin("Assign04_Group1", QIcon("c:\\fanucIcon.png")),
                    _pTestFrame(NULL) {
  // Initialize the UI graphics generated by QtCreator
  setupUi(this);

  // Connect signals from the ui component to slots implemented by this plugin
  connect(btnParse ,SIGNAL(pressed()), this, SLOT(clickBtnParse()) );
  connect(btnGenerate ,SIGNAL(pressed()), this, SLOT(clickBtnGenerate()) );
  connect(btnTest ,SIGNAL(pressed()), this, SLOT(clickBtnTest()) );
  }

assign04::~assign04() {
}

void assign04::initialize() {
  //const double val[] = {-1.571,1.053,-1.068,0,0.3,0};
  const double val[] = {-1.571,0,-1.068,0,0.3,0};
  _home = *new Q(6,val); // Configuration for position above writebox
  _origin = *new Transform3D<double>(Vector3D<double>(0.440,-0.010,0.950),
      RPY<double>(0.000,0.000,-M_PI)); // Approx (deg) -70, 70, -60, 0, 15, 0
}

void assign04::open(WorkCell* workcell) {
  _pWorkCell = workcell;
  if ( _pWorkCell->getDevices().size() == 0 )
    cout << "No devices in workcell." << endl;
  else {
    _pDevice = _pWorkCell->getDevices().front();
    cout << "Device loaded: " << _pDevice->getName() << endl << endl;
    btnParse->setEnabled(true);
    btnTest->setEnabled(true);
    inX->setEnabled(true); inY->setEnabled(true); inZ->setEnabled(true);
  }
}

void assign04::close() {
}

void assign04::clickBtnParse() {
  try {
    cout << "Selected input file: \n\t";

    QString selectedFilter;
    QString filename = QFileDialog::getOpenFileName(
      this,
      "Open file", // Title
      ".", // Directory
      "All supported ( *.txt )"
      " \n All ( *.* )",
      &selectedFilter);

    string file = filename.toStdString();
    const string ext = StringUtil::getFileExtension(file);

    if( ext != ".txt" )
      cout << "Unsupported file. Must be .txt; was: " << ext << endl;
    else {
      cout << file << endl << endl;
      ifstream infile (file.c_str());
      string line;
      char l;
      int a,b,c,d, index = 0;
      _vX.clear(); _vY.clear(); _vZ.clear(); _vLetters.clear(); _density = 0;

      if( infile.is_open() ) {
        while (! infile.eof() ) {
          getline (infile, line);
          if( sscanf(line.c_str(), "%d\t%d\t%d", &a, &b, &c) == 3 ) {
            _vX[index].push_back(a);
            _vY[index].push_back(b);
            _vZ[index].push_back(c);
          }
          else if( sscanf(line.c_str(), "Letter = %c", &l) == 1 ) {
            _vLetters.push_back(l);
            _vX.push_back(*new vector<int>());
            _vY.push_back(*new vector<int>());
            _vZ.push_back(*new vector<int>());
          }
          else if( strstr (line.c_str(),"NEXT_LETTER") != NULL ) {
            index++;
          }
          else if( sscanf(line.c_str(), "Density = %d", &d) == 1 ) {
            _density = d;
          }
        }
        cout << "Density: " << _density << endl;
        for(int i=0;i<index;i++) {
          cout << "Letter " << _vLetters[i] << ": ";
          cout << "Size: " << _vX[i].size() << endl;
        }
      }
    }
  }
  catch (exception& e) {
    cout << "An error occurred!\n\t" << e.what() << endl;
  }
  catch (int e) { cout << "int exception:\n\t" << e << endl; }
  catch (char e) { cout << "char exception:\n\t" << e << endl; }
  catch (...) { cout << "An unknown error occurred!" << endl; }

  if( !_vLetters.empty() && (_density != 0) && !_vX[0].empty() )
    btnGenerate->setEnabled(true);
  else
    btnGenerate->setEnabled(false);
}

void assign04::clickBtnGenerate() {
  const State state = getRobWorkStudio()->getState();
  vector<Q> path;
  Q pos = _pDevice->getQ(state);

  //path.push_back(pos);
  path.push_back(_home);

  Transform3D<double> transform, tmp;
  Q solution;
  double oldX = -1, oldY = -1, oldZ = -1;
  int cnt=0, miss=0;
  bool lift = false;
  
  cout << "Generating path." << endl;
  for( int i=0; i < _vLetters.size(); i++ ) {
    for( int j=0; j < _vX[i].size(); j++ ) {
      cnt++;
      transform = offset(_vX[i][j], _vY[i][j], _vZ[i][j]);
      
      if( oldX >= 0 && oldY >= 0 && oldZ >= 0 ) {
        if( abs((oldX - _vX[i][j])) > (_density + 1) ||
            abs((oldY - _vY[i][j])) > (_density + 1) ) 
          lift = true;
        else
          lift = false;
      }

      if( j != 0 && lift ) {
        tmp = offset(oldX, oldY, oldZ + 10);
        solution = IKSolver(tmp, state);
        //path.push_back(solution);
        if( !addSolution(solution, path) ) miss++;
      }
      if( j == 0 || lift ) {
        tmp = offset(0, 0, 10, transform);
        solution = IKSolver(tmp, state);
        //path.push_back(solution);
        if( !addSolution(solution, path) ) miss++;
      }

      solution = IKSolver(transform, state);
      //path.push_back(solution);
      if( !addSolution(solution, path) ) miss++;
      oldX = _vX[i][j]; oldY = _vY[i][j]; oldZ = _vZ[i][j];
      if( cnt % 10 == 0 )
        cout << ".";
    }
    tmp = offset(0, 0, 100, transform);
    solution = IKSolver(tmp, state);
    //path.push_back(solution);
    if( !addSolution(solution, path) ) miss++;
    
    cout << "\nGenerated path for the letter: " << _vLetters[i] << endl;
  }
  path.push_back(_home);
  cout << "Finished generating path!" << endl;
  cout << "\tLetter coordinates : " << cnt << endl;
  cout << "\tPath coordinates   : " << path.size() << endl;
  cout << "\tDropped coordinates: " << miss << endl;

  if( writeJNT(_pDevice->getName() + ".jnt", path) )
    cout << "jnt-file created!" << endl;

  const std::vector<State> states = QToStates(_pDevice, path, state);

  // Write the sequence of states to a file.
  PathLoader::storeVelocityTimedStatePath(
      *_pWorkCell, states, _pDevice->getName() + ".rwplay");
  cout << endl;
}

void assign04::clickBtnTest() {
  const State state = getRobWorkStudio()->getState();

  Transform3D<double> trans = offset(inX->value(),inY->value(),inZ->value());

  Q solution = IKSolver(trans,state);

  cout << "Testing (" << inX->value() << ", " << inY->value() << ", " 
       << inZ->value() << "):" << endl;
  if( !solution.empty() ) {
    cout << "  Values: " << solution << endl;
    updateDevice(solution, state);
  }
  else
    cout << "  No solution found." << endl;
  cout << "rToD test(pi): " << rToD(double(M_PI)) << endl;
  cout << "rToD test(-1.2): " << rToD(double(-1.2)) << endl;
}

const vector<State> assign04::pathPlanner(vector<Q>& confs, const State& state ) {
    // The path planning constraint is to avoid collisions.
    const PlannerConstraint constraint = PlannerConstraint::make( ProximityStrategyYaobi::make(), _pWorkCell, _pDevice, state);

    // An SBL based point-to-point path planner.
    QToQPlannerPtr planner = SBLPlanner::makeQToQPlanner(
        SBLSetup::make(constraint, _pDevice));

    std::vector<Q> path;
    for (int i = 0; i < (confs.size() - 1); i++) {
        const Q from = confs[i];
        Q to = confs[i+1];
        const bool ok = planner->query(from, to, path);
        if (!ok) {
            std::cout << "Path " << i << " not found.\n";
            break;
        }
    }
    /*
    // A sampler of collision free configurations for the device.
    QSamplerPtr cfreeQ = QSampler::makeConstrained(
        QSampler::makeUniform(_pDevice),
        constraint.getQConstraintPtr());

    // Plan 10 paths to sampled collision free configurations.
    std::vector<Q> path;
    for (int cnt = 0; cnt < 10; cnt++) {
        const Q next = cfreeQ->sample();
        const bool ok = planner->query(pos, next, path);
        if (!ok) {
            std::cout << "Path " << cnt << " not found.\n";
            return;
        } else {
            pos = next;
        }
    }
    */

    // Map the configurations to a sequence of states.
    return QToStates(_pDevice, path, state);
}

const vector<State> assign04::QToStates(DevicePtr device, vector<Q>& confs, 
                                        const State& state) {
  const std::vector<State> states = Models::getStatePath(*device, confs, state);
  return states;
}

Q assign04::IKSolver(const Transform3D<double>& baseTtool, const State& state) {
  ResolvedRateSolver iksolver(_pDevice, state);
  CollisionDetector *detector = NULL;

  IKMetaSolver metaSolver(&iksolver, _pDevice, detector);
  metaSolver.setMaxAttempts(50);
  metaSolver.setStopAtFirst(true); // No way of determining best solution?
  vector<Q> solutions = metaSolver.solve(baseTtool, state);

  Q out;
  if( solutions.empty() )
    out = *new Q();
  else
    out = solutions.front();
  return out; // Always only 1 solution.
}

Transform3D<double> assign04::offset(double x, double y, double z) {
  Vector3D<double> v(x/-1000,y/-1000,z/1000);
  return Transform3D<double>(_origin.P() + v,_origin.R());
}

Transform3D<double> assign04::offset(double x, double y, double z, Transform3D<double> t) {
  Vector3D<double> v(x/-1000,y/-1000,z/1000);
  return Transform3D<double>(t.P() + v, t.R());
}

void assign04::updateDevice(Q q, State state) {
  if( _pDevice != NULL ) {
    _pDevice->setQ(q, state);
    getRobWorkStudio()->setState(state);
  }
}

bool assign04::addSolution(Q q, vector<Q>& v) {
  bool return_value = false;
  if( q.size() == 6 ) {
    v.push_back(q);
    return_value = true;
  }
  return return_value;
}

bool assign04::writeJNT(string name, vector<Q>& confs) {
  bool return_value = false;
  try {
    if( confs.size() > 0 ) {
      FILE * pFile;
      pFile = fopen(name.c_str(),"w");
      int i=0;
      fprintf(pFile, "JNT, %d, %#.4f, %#.4f, %#.4f, %#.4f, %#.4f, %#.4f, 0, 5000, 4, 1500, 10, 10\n", i+1, rToD(confs[i][0]), rToD(confs[i][1]), rToD(confs[i][2]), rToD(confs[i][3]), rToD(confs[i][4]), rToD(confs[i][5]));
      for( i=1; i < confs.size()-1; i++ )
        fprintf(pFile, "JNT, %d, %#.4f, %#.4f, %#.4f, %#.4f, %#.4f, %#.4f, 0, 200, 4, 1500, 10, 75\n", i+1, rToD(confs[i][0]), rToD(confs[i][1]), rToD(confs[i][2]), rToD(confs[i][3]), rToD(confs[i][4]), rToD(confs[i][5]));
      fprintf(pFile, "JNT, %d, %#.4f, %#.4f, %#.4f, %#.4f, %#.4f, %#.4f, 0, 5000, 4, 1500, 10, 10\n", i+1, rToD(confs[i][0]), rToD(confs[i][1]), rToD(confs[i][2]), rToD(confs[i][3]), rToD(confs[i][4]), rToD(confs[i][5]));
      fclose (pFile);
      return_value = true;
    }
  }
  catch(...) {
    cout << "Unhandled IO exception!" << endl;
  }
  return return_value;
}

double assign04::rToD(double r) {
  return r*180/M_PI;
}

Q_EXPORT_PLUGIN(assign04);
