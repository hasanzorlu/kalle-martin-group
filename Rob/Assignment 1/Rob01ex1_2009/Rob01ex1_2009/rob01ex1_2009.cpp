#include "rob01ex1_2009.h"

#include <QPushButton>

// needed for VS
#define _USE_MATH_DEFINES
#include <cmath>
#define M_PI       3.14159265358979323846

#include <rws/RobWorkStudio.hpp>

using namespace rw::math;
using namespace rw::common;
using namespace rw::kinematics;
using namespace rw::models;
using namespace rwlibs::drawable;

Rob01ex1_2009::Rob01ex1_2009():
    RobWorkStudioPlugin("Rob01Ex1Plugin", QIcon("pax_icon.png")),
    	_pTestFrame(NULL)
{
	// Initialize the UI graphics generated by QtCreator
	setupUi(this);

    // Connect signals from the ui component to slots implemented by this plugin

	connect(btnInsertFrame ,SIGNAL(pressed()), this, SLOT(clickBtnInsertFrame()) );
	connect(btnSolve ,SIGNAL(pressed()), this, SLOT(clickBtnSolve()) );
	connect(btnSliderReset ,SIGNAL(pressed()), this, SLOT(clickBtnSliderReset()) );

	connect(btnUser1 ,SIGNAL(pressed()), this, SLOT(clickBtnUser1()) );
    connect(btnUser2 ,SIGNAL(pressed()), this, SLOT(clickBtnUser2()) );
    connect(btnUser3 ,SIGNAL(pressed()), this, SLOT(clickBtnUser3()) );
    connect(btnUser4 ,SIGNAL(pressed()), this, SLOT(clickBtnUser4()) );

    connect(sldRoll ,SIGNAL(valueChanged(int)), this, SLOT(valueChangedRPY()) );
    connect(sldPitch ,SIGNAL(valueChanged(int)), this, SLOT(valueChangedRPY()) );
    connect(sldYaw ,SIGNAL(valueChanged(int)), this, SLOT(valueChangedRPY()) );
    //connect(dsRoll ,SIGNAL(valueChanged(double)), this, SLOT(valueChangedRPY()) );
    //connect(dsPitch ,SIGNAL(valueChanged(double)), this, SLOT(valueChangedRPY()) );
    //connect(dsYaw ,SIGNAL(valueChanged(double)), this, SLOT(valueChangedRPY()) );

    connect(cbAngleSet, SIGNAL(activated(QString)), this, SLOT(angleSetSelected(QString)));
}

Rob01ex1_2009::~Rob01ex1_2009()
{

}

void Rob01ex1_2009::initialize() {
    getRobWorkStudio()->stateChangedEvent().add(boost::bind(&Rob01ex1_2009::stateChangedListener, this, _1), this);
	_bolUpdating = false;
}

//3
void Rob01ex1_2009::open(WorkCell* workcell)
{
	_pWorkCell = workcell;

	//insertFrame("TestFrame"); //CRASH, do it from a button instead.

	// Show WorldFrame
	addRenderFrame(workcell->getWorldFrame(),0.5);

	// Set the stats label
	lblStatus->setText("Welcome to ROB01-EX1");

	btnInsertFrame->setEnabled(true);
	_strAngleSet = cbAngleSet->currentText();
}

void Rob01ex1_2009::close() {
}



void Rob01ex1_2009::stateChangedListener(const State& state) {

}

void Rob01ex1_2009::clickBtnInsertFrame() {

	_pTestFrame = insertFrame("TestFrame");
	addRenderFrame(_pTestFrame,1.0);

	btnInsertFrame->setEnabled(false);

}

void Rob01ex1_2009::clickBtnSolve() {

	std::cout << "Rob01Ex1Plugin::clickBtnSolve()" << std::endl;
	std::cout << "current AngleSet: " << _strAngleSet.toStdString() << std::endl;
	
	updateAngles();
}

void Rob01ex1_2009::clickBtnSliderReset() {

	sldRoll->setValue(0.0);
	sldPitch->setValue(0.0);
	sldYaw->setValue(0.0);

}


void Rob01ex1_2009::clickBtnUser1() {

	std::cout << "Rob01Ex1Plugin::clickBtnUser1()" << std::endl;

}

void Rob01ex1_2009::clickBtnUser2() {

	std::cout << "Rob01Ex1Plugin::clickBtnUser2()" << std::endl;

}

void Rob01ex1_2009::clickBtnUser3() {

	std::cout << "Rob01Ex1Plugin::clickBtnUser3()" << std::endl;

}

void Rob01ex1_2009::clickBtnUser4() {

	std::cout << "Rob01Ex1Plugin::clickBtnUser4()" << std::endl;

}

void Rob01ex1_2009::valueChangedRPY(){

	if (_pTestFrame == NULL) return;
	if (_bolUpdating == true) return;

	QObject* object = sender();

	double r,p,y;

	if ((object == sldRoll) || (object == sldPitch) || (object == sldYaw)) {

		r = (sldRoll->value() / 1000.0) * M_PI;
		p = (sldPitch->value() / 1000.0) * M_PI;
		y = (sldYaw->value() / 1000.0) * M_PI;

		// Update spinboxes with current values
		dsRoll->setValue(r);
		dsPitch->setValue(p);
		dsYaw->setValue(y);

	}

	//this is kind of ugly and gives jerky movements of the frame visualization...
	/*if ((object == dsRoll) || (object == dsPitch) || (object == dsYaw)) {

		r = dsRoll->value();
		p = dsPitch->value();
		y = dsYaw->value();

		// Update sliders with current values
		sldRoll->setValue( (r/M_PI) * 1000.0 );
		sldPitch->setValue( (p/M_PI) * 1000.0 );
		sldYaw->setValue( (y/M_PI) * 1000.0 );
	}*/

	// Update Rotation Matrix
	Rotation3D<double> rotation = updateRotation();

	// Update Frame
	updateFrame(rotation);

	return;
}

void Rob01ex1_2009::angleSetSelected(QString selectionString){

	std::cout << "Rob01Ex1Plugin::angleSetSelected()" << std::endl;
	std::cout << "\t " << selectionString.toStdString() << std::endl;

	_strAngleSet = selectionString;

	//Update slider annotation
	QStringList tokens = selectionString.split(" ");
	if (tokens.at(0) == "Euler"){
		lblSlider1->setText("y");
		//lblSlider1->setText(QChar(947));
		lblSlider2->setText("b");
		//lblSlider2->setText(QChar(946));
		lblSlider3->setText("a");
		//lblSlider3->setText(QChar(945));
	}
	else if (tokens.at(0) == "Fixed"){
		lblSlider1->setText("R");
		lblSlider2->setText("P");
		lblSlider3->setText("Y");
	}

	// TODO : insert your code here
	if( selectionString == "Euler ZYX" || selectionString == "Fixed XYZ" ||
		selectionString == "Euler XYZ" || selectionString == "Fixed ZYX" ||
		selectionString == "Euler XZY" || selectionString == "Fixed YZX" ||
		selectionString == "Euler YXZ" || selectionString == "Fixed ZXY" ||
		selectionString == "Euler ZXZ" || selectionString == "Fixed ZXZ" ||
		selectionString == "Euler ZYZ" || selectionString == "Fixed ZYZ" ){
	
		updateRotation();
		enableInterface(true);
	}
	else{
		std::cout << "\tAngleSet not implemented." << std::endl;
		enableInterface(false);
	}
}

// Inserts a MovableFrame into the workcell with reference to WorldFrame
MovableFrame* Rob01ex1_2009::insertFrame(std::string name){

	// Create and add the movable daf frame to WC
	MovableFrame *newFrame = new MovableFrame(name);
    _pWorkCell->getStateStructure()->addDAF(newFrame,_pWorkCell->getWorldFrame());

    // Now this is VERY important; remember to update the WC state structure
    State state = getRobWorkStudio()->getState();
    state = _pWorkCell->getStateStructure()->upgradeState(state);

    //Initialize transformation
    Rotation3D<double> targetR(1,0,0,0,1,0,0,0,1);
	Vector3D<double> targetP(0,0,1.5);
	Transform3D<double> target(targetP,targetR);
	newFrame->setTransform(target,state);

	// Attach frame to the reference frame
	newFrame->attachTo(_pWorkCell->getWorldFrame(),state);
	getRobWorkStudio()->setState(state);

	return newFrame;

}

// Adds a red-green-blue visualization to a frame
void Rob01ex1_2009::addRenderFrame(Frame* frame, float scale){

	RenderFrame* pRenderFrame = new RenderFrame(scale);
	Drawable* pRFDrawable = new Drawable(pRenderFrame);

	getRobWorkStudio()->getWorkCellGLDrawer()->addDrawableToFrame(frame, pRFDrawable);

	return;
}

//--------------
// New functions
//--------------
rw::math::RPY<double> Rob01ex1_2009::updateAngles(){
	
	double r,p,y,r11,r12,r13,r21,r22,r23,r31,r32,r33,sum,sin_beta,cos_beta;
	
	r11 = sbR11->value(); r12 = sbR12->value(); r13 = sbR13->value();
	r21 = sbR21->value(); r22 = sbR22->value(); r23 = sbR23->value();
	r31 = sbR31->value(); r32 = sbR32->value(); r33 = sbR33->value();

	RPY<double> rpy;
	Rotation3D<double> rotation(r11,r12,r13,r21,r22,r23,r31,r32,r33);

	if(_strAngleSet == "Euler ZYX" || _strAngleSet == "Fixed XYZ"){
		// Calculate r,p,y from Robworks inbuilt function
		RPY<double> my_rpy(rotation);
		r = my_rpy(0); p = my_rpy(1); y = my_rpy(2);
	}
	else if(_strAngleSet == "Euler XYZ" || _strAngleSet == "Fixed ZYX"){
		sum = r11*r11 + r12*r12;
		if(sum < 0) sum = 0;
		
		cos_beta = sqrt(sum); sin_beta = r13;
		
		// If beta == 90 deg or beta == -90 deg
		if (fabs(cos_beta) < 1e-5){
			// beta == -90 deg
			if (sin_beta < 0) {
				r = 0; p = (-Pi / 2); y = atan2(-r32, r31);
			}
			// beta == 90 deg
			else{
				r = 0; p = (Pi / 2); y = atan2(r32, -r31);
			}
		}
		else{
			r = atan2(-r23/cos_beta, r33/cos_beta);
			p = atan2(sin_beta, cos_beta);
			y = atan2(-r12/cos_beta, r11/cos_beta);
		}
	}
	else if(_strAngleSet == "Euler XZY" || _strAngleSet == "Fixed YZX"){
		sum = r11*r11 + r13*r13;
		if(sum < 0) sum = 0;
		
		cos_beta = sqrt(sum); sin_beta = -r12;
		
		// If beta == 90 deg or beta == -90 deg
		if (fabs(cos_beta) < 1e-5){
			// beta == -90 deg
			if (sin_beta < 0) {
				r = 0; p = (-Pi / 2); y = atan2(-r23, -r21);
			}
			// beta == 90 deg
			else{
				r = 0; p = (Pi / 2); y = atan2(r23, r21);
			}
		}
		else{
			r = atan2(r32/cos_beta, r22/cos_beta);
			p = atan2(sin_beta, cos_beta);
			y = atan2(r13/cos_beta, r11/cos_beta);
		}
	}
	else if(_strAngleSet == "Euler YXZ" || _strAngleSet == "Fixed ZXY"){
		sum = r21*r21 + r22*r22;
		if(sum < 0) sum = 0;
		
		cos_beta = sqrt(sum); sin_beta = -r23;
		
		// If beta == 90 deg or beta == -90 deg
		if (fabs(cos_beta) < 1e-5){
			// beta == -90 deg
			if (sin_beta < 0) {
				r = 0; p = (-Pi / 2); y = atan2(-r31, -r32);
			}
			// beta == 90 deg
			else{
				r = 0; p = (Pi / 2); y = atan2(r31, r32);
			}
		}
		else{
			r = atan2(r13/cos_beta, r33/cos_beta);
			p = atan2(sin_beta, cos_beta);
			y = atan2(r21/cos_beta, r22/cos_beta);
		}
	}
	else if(_strAngleSet == "Euler ZXZ" || _strAngleSet == "Fixed ZXZ"){
		sum = r31*r31 + r32*r32;
		if(sum < 0) sum = 0;
		
		sin_beta = sqrt(sum); cos_beta = r33;
		
		// If beta == 0 deg or beta == 180 deg
		if (fabs(sin_beta) < 1e-5){
			// beta == 0 deg
			if (cos_beta > 0) {
				r = 0; p = 0; y = atan2(r21, r22);
			}
			// beta == 180 deg
			else{
				r = 0; p = Pi; y = atan2(-r21, -r22);
			}
		}
		else{
			r = atan2(r13/sin_beta, -r23/sin_beta);
			p = atan2(sin_beta,cos_beta);
			y = atan2(r31/sin_beta, r32/sin_beta);
		}
	}
	else if(_strAngleSet == "Euler ZYZ" || _strAngleSet == "Fixed ZYZ"){
		sum = r31*r31 + r32*r32;
		if(sum < 0) sum = 0;
		
		sin_beta = sqrt(sum); cos_beta = r33;
		
		// If beta == 0 deg or beta == 180 deg
		if (fabs(sin_beta) < 1e-5){
			// beta == 0 deg
			if (cos_beta > 0) {
				r = 0; p = 0; y = atan2(-r12, r11);
			}
			// beta == 180 deg
			else{
				r = 0; p = Pi; y = atan2(r12, -r11);
			}
		}
		else{
			r = atan2(r23/sin_beta, r13/sin_beta);
			p = atan2(sin_beta,cos_beta);
			y = atan2(r32/sin_beta, -r31/sin_beta);
		}
	}
	else{
		r = 0; p = 0; y = 0;
	}

	// Update the sliders
	_bolUpdating = true;
	dsRoll->setValue(r);
	dsPitch->setValue(p);
	dsYaw->setValue(y);
	sldRoll->setValue( (r/M_PI) * 1000.0 );
	sldPitch->setValue( (p/M_PI) * 1000.0 );
	sldYaw->setValue( (y/M_PI) * 1000.0 );
	_bolUpdating = false;

	updateFrame(rotation);

	rpy = RPY<double>(r,p,y);
	return rpy;
}

rw::math::Rotation3D<double> Rob01ex1_2009::updateRotation(){
	
	Rotation3D<double> rotation;
	double r,p,y,ca,cb,cg,sa,sb,sg;
	r = dsRoll->value();
	p = dsPitch->value();
	y = dsYaw->value();

	ca = cos(r);
	sa = sin(r);
	cb = cos(p);
	sb = sin(p);
	cg = cos(y);
	sg = sin(y);

	if(_strAngleSet == "Euler ZYX" || _strAngleSet == "Fixed XYZ"){
		RPY<double> my_rpy(r,p,y);
		rotation = my_rpy.toRotation3D();
	}
	else if(_strAngleSet == "Euler XYZ" || _strAngleSet == "Fixed ZYX"){
		rotation = Rotation3D<double>(
			cb*cg,             /**/ -cb*sg,            /**/ sb,
			sa*sb*cg + ca*sg,  /**/ -sa*sb*sg + ca*cg, /**/ -sa*cb,
			-ca*sb*cg + sa*sg, /**/ ca*sb*sg + sa*cg,  /**/ ca*cb
		);
	}
	else if(_strAngleSet == "Euler XZY" || _strAngleSet == "Fixed YZX"){
		rotation = Rotation3D<double>(
			cb*cg,             /**/ -sb,               /**/ cb*sg,
			ca*sb*cg + sa*sg,  /**/ ca*cb,             /**/ ca*sb*sg - sa*cg,
			sa*sb*cg - ca*sg,  /**/ sa*cb,             /**/ sa*sb*sg + ca*cg
		);
	}
	else if(_strAngleSet == "Euler YXZ" || _strAngleSet == "Fixed ZXY"){
		rotation = Rotation3D<double>(
			sa*sb*sg + ca*cg,  /**/ sa*sb*cg - ca*sg,  /**/ sa*cb,
			cb*sg,             /**/ cb*cg,             /**/ -sb,
			ca*sb*sg - sa*cg,  /**/ ca*sb*cg + sa*sg,  /**/ ca*cb
		);
	}
	else if(_strAngleSet == "Euler ZXZ" || _strAngleSet == "Fixed ZXZ"){
		rotation = Rotation3D<double>(
			-sa*cb*sg + ca*cg, /**/ -sa*cb*cg - ca*sg, /**/ sa*sb,
			ca*cb*sg + sa*cg,  /**/ ca*cb*cg - sa*sg,  /**/ -ca*sb,
			sb*sg,             /**/ sb*cg,             /**/ cb
		);
	}
	else if(_strAngleSet == "Euler ZYZ" || _strAngleSet == "Fixed ZYZ"){
		rotation = Rotation3D<double>(
			ca*cb*cg - sa*sg,  /**/ -ca*cb*sg - sa*cg, /**/ ca*sb,
			sa*cb*cg + ca*sg,  /**/ -sa*cb*sg + ca*cg, /**/ sa*sb,
			-sb*cg,            /**/ sb*sg,             /**/ cb
		);
	}
	else
		rotation = Rotation3D<double>(1,0,0,0,1,0,0,0,1);

	// Update the rotation matrix display
	sbR11->setValue(rotation(0,0));
	sbR12->setValue(rotation(0,1));
	sbR13->setValue(rotation(0,2));
	sbR21->setValue(rotation(1,0));
	sbR22->setValue(rotation(1,1));
	sbR23->setValue(rotation(1,2));
	sbR31->setValue(rotation(2,0));
	sbR32->setValue(rotation(2,1));
	sbR33->setValue(rotation(2,2));
	
	return rotation;
}

void Rob01ex1_2009::updateFrame(Rotation3D<double> rotation){

	Vector3D<double> translation(0,0,1.5);
	Transform3D<double> my_transform(translation,rotation);

	// Apply the transformation to the movable frame
	State state = getRobWorkStudio()->getState();
	_pTestFrame->setTransform(my_transform,state);
	getRobWorkStudio()->setState(state);
}

void Rob01ex1_2009::enableInterface(bool b){
	sbR11->setEnabled(b); sbR12->setEnabled(b); sbR13->setEnabled(b);
	sbR21->setEnabled(b); sbR22->setEnabled(b); sbR23->setEnabled(b);
	sbR31->setEnabled(b); sbR32->setEnabled(b); sbR33->setEnabled(b);
	sldRoll->setEnabled(b);
	sldPitch->setEnabled(b);
	sldYaw->setEnabled(b);
	btnSolve->setEnabled(b);
}

Q_EXPORT_PLUGIN(Rob01ex1_2009);
